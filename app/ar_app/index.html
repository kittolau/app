<!DOCTYPE html>
<html lang="en">
<head>
    <title>AR Viewer - Dynamic Model Loading</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="lib/aframe.min.js"></script>
    <script src="lib/aframe-ar.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        
        /* AR message overlay */
        #ar-hover-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            z-index: 1000;
            display: none;
            max-width: 90%;
            text-align: center;
        }
        
        #ar-hover-message h3 {
            margin: 0 0 10px 0;
            font-size: 18px;
            font-weight: bold;
        }
        
        #speak-button {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(calc(-100% - 10px));
            background-color: rgba(33, 150, 243, 0.9);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s;
        }
        
        #speak-button:hover {
            background-color: rgba(33, 150, 243, 1);
        }
        
        #speak-button:active {
            background-color: rgba(25, 118, 210, 1);
        }
        
        #speak-button.speaking {
            background-color: rgba(244, 67, 54, 0.9);
        }
        
        #speak-button.speaking:hover {
            background-color: rgba(244, 67, 54, 1);
        }
        
        #youtube-button {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(10px);
            background-color: rgba(255, 0, 0, 0.9);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s;
        }
        
        #youtube-button:hover {
            background-color: rgba(255, 0, 0, 1);
        }
        
        #youtube-button:active {
            background-color: rgba(204, 0, 0, 1);
        }
        
        #youtube-button svg {
            vertical-align: middle;
            margin-right: 8px;
        }
        
        #video-button {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(10px);
            background-color: rgba(76, 175, 80, 0.9);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s;
        }
        
        #video-button:hover {
            background-color: rgba(76, 175, 80, 1);
        }
        
        #video-button:active {
            background-color: rgba(56, 142, 60, 1);
        }
        
        #video-button svg {
            vertical-align: middle;
            margin-right: 8px;
        }
        
        /* Instructions */
        #instructions {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 144, 255, 0.9);
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            font-size: 0.95em;
            z-index: 1500;
            text-align: center;
            max-width: 90%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        /* Responsive adjustments */
        @media (max-width: 540px) {
            #ar-hover-message {
                font-size: 1.3em;
                padding: 16px 24px;
            }
            
            #instructions {
                font-size: 0.85em;
                padding: 10px 16px;
            }
        }
    </style>
</head>
<body>
    <!-- Instructions for users -->
    <div id="instructions">
        Ë´ãÂ∞áÁõ∏Ê©üÂ∞çÊ∫ñARÊ®ôË®ò‰ª•Êü•Áúã
    </div>
    
    <!-- AR message when marker is detected -->
    <div id="ar-hover-message">
        <h3 id="model-title">Model Detected</h3>
    </div>
    
    <button id="speak-button">üîä Èü≥È†ªËß£Ë™™</button>
    
    <button id="youtube-button">
        <svg width="20" height="14" viewBox="0 0 20 14" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path d="M19.582 2.186c-.23-.86-.907-1.537-1.768-1.768C16.254 0 10 0 10 0S3.746 0 2.186.418c-.86.23-1.537.908-1.768 1.768C0 3.746 0 7 0 7s0 3.254.418 4.814c.23.86.908 1.537 1.768 1.768C3.746 14 10 14 10 14s6.254 0 7.814-.418c.86-.23 1.537-.908 1.768-1.768C20 10.254 20 7 20 7s0-3.254-.418-4.814zM8 10V4l5.196 3L8 10z"/>
        </svg>
        ËßÄÁúãÂΩ±Áâá
    </button>
    
    <button id="video-button">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path d="M8 5v14l11-7z"/>
        </svg>
        Êí≠ÊîæÂΩ±Áâá
    </button>
    
    <!-- A-Frame AR Scene -->
    <a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;' vr-mode-ui="enabled: false" renderer="colorManagement: true; physicallyCorrectLights: true;" id="ar-scene">
        <!-- Global lighting for PBR materials -->
        <a-entity light="type: ambient; color: #BBB; intensity: 1"></a-entity>
        <a-entity light="type: hemisphere; color: #FFF; groundColor: #888; intensity: 1"></a-entity>
        <a-entity light="type: directional; color: #FFF; intensity: 0.6" position="-1 2 1"></a-entity>
        
        <!-- Multiple markers - AR.js can handle pattern markers, NFT image tracking, and barcodes -->
        <a-entity camera></a-entity>
    </a-scene>
    
    <script>
        // Global variables for multi-model support
        var modelConfigs = {};
        var modelDescriptions = {};
        var availableModels = [];
        var currentModel = null;
        var speechSynthesis = window.speechSynthesis;
        var currentUtterance = null;
        
        console.log('=== AR Viewer (Multi-Marker & NFT Support) ===');
        
        // Function to setup orbit animation
        function setupOrbitAnimation(orbitContainer, speed) {
            var currentAngle = 0;
            var rotationSpeed = speed * 0.5; // Adjust speed multiplier
            
            // Animation loop
            function animate() {
                if (orbitContainer && orbitContainer.object3D) {
                    currentAngle += rotationSpeed;
                    if (currentAngle >= 360) {
                        currentAngle -= 360;
                    }
                    orbitContainer.object3D.rotation.y = currentAngle * Math.PI / 180;
                }
                requestAnimationFrame(animate);
            }
            
            // Start animation
            animate();
        }
        
        // Load model list and cache all configurations
        fetch('model/model_list.json')
            .then(function(response) {
                if (!response.ok) {
                    throw new Error('Model list not found');
                }
                return response.json();
            })
            .then(function(data) {
                console.log('‚úì Model list loaded:', data);
                availableModels = data.models || [];
                
                // Load and cache all model configurations
                return Promise.all(availableModels.map(function(modelName) {
                    return loadModelConfig(modelName);
                }));
            })
            .then(function() {
                console.log('‚úì All model configurations cached');
                console.log('Available models:', Object.keys(modelConfigs));
                
                // Initialize AR scene with all markers
                initializeARScene();
            })
            .catch(function(error) {
                console.error('‚ö†Ô∏è Failed to load model configurations:', error);
                // Fallback to single model mode
                initializeFallbackMode();
            });
        
        // Load configuration for a specific model
        function loadModelConfig(modelName) {
            return fetch('model/' + modelName + '/config.json')
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Config not found for ' + modelName);
                    }
                    return response.json();
                })
                .then(function(data) {
                    // Cache model configuration
                    modelConfigs[modelName] = {
                        size: data.size || 0.3,
                        posX: data.position ? data.position.x || 0 : 0,
                        posY: data.position ? data.position.y || 0 : 0,
                        posZ: data.position ? data.position.z || 0 : 0,
                        rotX: data.rotation ? data.rotation.x || 0 : 0,
                        rotY: data.rotation ? data.rotation.y || 0 : 0,
                        rotZ: data.rotation ? data.rotation.z || 0 : 0,
                        markerType: data.marker_type || 'pattern', // 'pattern', 'nft', or 'barcode'
                        nftDescriptor: data.nft_descriptor || null, // Path to NFT descriptor files (without extension)
                        modelFile: data.model_file || 'model.gltf', // Support both .gltf and .glb files
                        // Orbit animation settings
                        spinAroundEarth: data.spin_around_earth_orbit || false,
                        earth: data.earth ? {
                            modelFile: data.earth.model_file || null,
                            size: data.earth.size || 0.5,
                            posX: data.earth.position ? data.earth.position.x || 0 : 0,
                            posY: data.earth.position ? data.earth.position.y || 0 : 0,
                            posZ: data.earth.position ? data.earth.position.z || 0 : 0,
                            rotX: data.earth.rotation ? data.earth.rotation.x || 0 : 0,
                            rotY: data.earth.rotation ? data.earth.rotation.y || 0 : 0,
                            rotZ: data.earth.rotation ? data.earth.rotation.z || 0 : 0
                        } : null,
                        orbitRadius: data.orbit_radius || 2,
                        orbitSpeed: data.orbit_speed || 1,
                        orbitTilt: data.orbit_tilt || 0
                    };
                    
                    // Cache description info
                    modelDescriptions[modelName] = {
                        title: data.desc_info ? data.desc_info.title || modelName : modelName,
                        hk_narrative: data.desc_info ? data.desc_info.hk_narrative || 'AR Model' : 'AR Model',
                        youtube_video_src: data.desc_info ? data.desc_info.youtube_video_src || null : null,
                        local_video_src: data.desc_info ? data.desc_info.local_video_src || null : null
                    };
                    
                    console.log('‚úì Cached config for:', modelName, '(Type:', data.marker_type || 'pattern', ', Model:', data.model_file || 'model.gltf', ')');
                })
                .catch(function(error) {
                    console.error('‚ö†Ô∏è Failed to load config for', modelName, ':', error);
                    // Set default config for failed models
                    modelConfigs[modelName] = {
                        size: 0.3, posX: 0, posY: 0, posZ: 0, rotX: 0, rotY: 0, rotZ: 0
                    };
                    modelDescriptions[modelName] = {
                        title: modelName,
                        hk_narrative: 'AR Model'
                    };
                });
        }
        
        // Initialize AR scene with multiple markers
        function initializeARScene() {
            var scene = document.getElementById('ar-scene');
            if (!scene) {
                console.error('AR scene not found');
                return;
            }
            
            if (availableModels.length === 0) {
                console.error('No models available');
                return;
            }
            
            // Create a marker for each model - AR.js will detect whichever is visible
            availableModels.forEach(function(modelName) {
                createMarkerForModel(scene, modelName);
            });
            
            console.log('‚úì AR scene initialized with', availableModels.length, 'markers');
        }
        
        // Create a marker and model for a specific model
        function createMarkerForModel(scene, modelName) {
            var config = modelConfigs[modelName];
            if (!config) {
                console.warn('No config found for:', modelName);
                return;
            }
            
            // Create marker element based on type
            var marker = document.createElement('a-nft');
            var markerType = config.markerType || 'pattern';
            
            if (markerType === 'nft' && config.nftDescriptor) {
                // NFT (Natural Feature Tracking) marker
                marker = document.createElement('a-nft');
                marker.setAttribute('type', 'nft');
                marker.setAttribute('url', config.nftDescriptor);
                marker.setAttribute('smooth', 'true');
                marker.setAttribute('smoothCount', '10');
                marker.setAttribute('smoothTolerance', '0.01');
                marker.setAttribute('smoothThreshold', '5');
                console.log('Creating NFT marker for:', modelName, 'with descriptor:', config.nftDescriptor);
            } else if (markerType === 'barcode') {
                // Barcode/QR marker
                marker = document.createElement('a-marker');
                marker.setAttribute('type', 'barcode');
                marker.setAttribute('value', config.barcodeValue || '0');
                console.log('Creating barcode marker for:', modelName);
            } else {
                // Pattern marker (default)
                marker = document.createElement('a-marker');
                marker.setAttribute('type', 'pattern');
                marker.setAttribute('url', 'model/' + modelName + '/pattern-marker.patt');
                console.log('Creating pattern marker for:', modelName);
            }
            
            marker.setAttribute('id', 'marker-' + modelName);
            marker.setAttribute('raycaster', 'objects: .clickable');
            
            // Check if this model should orbit around Earth
            if (config.spinAroundEarth && config.earth && config.earth.modelFile) {
                // Create Earth model at center
                var earthEntity = document.createElement('a-entity');
                earthEntity.setAttribute('id', 'earth-' + modelName);
                earthEntity.setAttribute('gltf-model', 'model/' + modelName + '/' + config.earth.modelFile);
                earthEntity.setAttribute('scale', config.earth.size + ' ' + config.earth.size + ' ' + config.earth.size);
                earthEntity.setAttribute('position', config.earth.posX + ' ' + config.earth.posY + ' ' + config.earth.posZ);
                earthEntity.setAttribute('rotation', config.earth.rotX + ' ' + config.earth.rotY + ' ' + config.earth.rotZ);
                marker.appendChild(earthEntity);
                
                // Create orbit container (this will rotate)
                var orbitContainer = document.createElement('a-entity');
                orbitContainer.setAttribute('id', 'orbit-container-' + modelName);
                orbitContainer.setAttribute('position', '0 0 0');
                orbitContainer.setAttribute('rotation', config.orbitTilt + ' 0 0');
                
                // Create model entity at orbit radius
                var modelEntity = document.createElement('a-entity');
                modelEntity.setAttribute('id', 'model-' + modelName);
                var modelFile = config.modelFile || 'model.gltf';
                modelEntity.setAttribute('gltf-model', 'model/' + modelName + '/' + modelFile);
                modelEntity.setAttribute('scale', config.size + ' ' + config.size + ' ' + config.size);
                modelEntity.setAttribute('position', config.orbitRadius + ' 0 0');
                modelEntity.setAttribute('rotation', config.rotX + ' ' + config.rotY + ' ' + config.rotZ);
                
                // Add model to orbit container
                orbitContainer.appendChild(modelEntity);
                
                // Add orbit container to marker
                marker.appendChild(orbitContainer);
                
                // Setup orbit animation
                setupOrbitAnimation(orbitContainer, config.orbitSpeed);
                
                console.log('‚úì Created orbit setup for:', modelName, 'radius:', config.orbitRadius, 'speed:', config.orbitSpeed);
            } else {
                // Standard model without orbit
                var modelEntity = document.createElement('a-entity');
                modelEntity.setAttribute('id', 'model-' + modelName);
                
                // Support both .gltf and .glb files
                var modelFile = config.modelFile || 'model.gltf';
                modelEntity.setAttribute('gltf-model', 'model/' + modelName + '/' + modelFile);
                
                // Apply cached configuration
                if (config) {
                    modelEntity.setAttribute('scale', config.size + ' ' + config.size + ' ' + config.size);
                    modelEntity.setAttribute('position', config.posX + ' ' + config.posY + ' ' + config.posZ);
                    modelEntity.setAttribute('rotation', config.rotX + ' ' + config.rotY + ' ' + config.rotZ);
                }
                
                // Add model to marker
                marker.appendChild(modelEntity);
            }
            
            // Wait for model to load and add proper PBR lighting
            modelEntity.addEventListener('model-loaded', function() {
                console.log('‚úì Model loaded:', modelName);
                
                // Add hemisphere light for better PBR rendering
                var hemisphereLight = document.createElement('a-entity');
                hemisphereLight.setAttribute('light', 'type: hemisphere; color: #FFF; groundColor: #555; intensity: 1.5');
                hemisphereLight.setAttribute('position', '0 2 0');
                marker.appendChild(hemisphereLight);
                
                // Add directional light from multiple angles for PBR reflections
                var keyLight = document.createElement('a-entity');
                keyLight.setAttribute('light', 'type: directional; color: #FFF; intensity: 1.5');
                keyLight.setAttribute('position', '2 4 2');
                marker.appendChild(keyLight);
                
                var fillLight = document.createElement('a-entity');
                fillLight.setAttribute('light', 'type: directional; color: #FFF; intensity: 0.8');
                fillLight.setAttribute('position', '-2 3 -1');
                marker.appendChild(fillLight);
                
                // Add point light close to model for highlights
                var pointLight = document.createElement('a-entity');
                pointLight.setAttribute('light', 'type: point; color: #FFF; intensity: 1; distance: 10; decay: 2');
                pointLight.setAttribute('position', '0 2 1');
                marker.appendChild(pointLight);
                
                console.log('‚úì PBR lighting setup complete for:', modelName);
            });
            
            // Add marker event listeners
            marker.addEventListener('markerFound', function() {
                onMarkerFound(modelName);
            });
            
            marker.addEventListener('markerLost', function() {
                onMarkerLost(modelName);
            });
            
            // Add marker to scene
            scene.appendChild(marker);
            
            console.log('‚úì Created marker for:', modelName);
        }
        
        // Handle marker found event
        function onMarkerFound(modelName) {
            console.log('‚úÖ Marker detected:', modelName, new Date().toLocaleTimeString());
            currentModel = modelName;
            
            // Update AR message with model-specific info
            updateARMessage(modelName);
            
            // Show overlay, speak button and hide instructions
            var hoverMsg = document.getElementById('ar-hover-message');
            var speakBtn = document.getElementById('speak-button');
            var youtubeBtn = document.getElementById('youtube-button');
            var videoBtn = document.getElementById('video-button');
            var instructions = document.getElementById('instructions');
            
            if (hoverMsg) {
                hoverMsg.style.display = 'block';
            }
            if (speakBtn) {
                speakBtn.style.display = 'block';
            }
            
            // Get model description
            var desc = modelDescriptions[modelName];
            
            // Show YouTube button if youtube_video_src exists
            if (youtubeBtn && desc && desc.youtube_video_src) {
                youtubeBtn.style.display = 'block';
                youtubeBtn.onclick = function() {
                    window.open(desc.youtube_video_src, '_blank');
                };
            }
            
            // Show Video button if local_video_src exists (priority over YouTube)
            if (videoBtn && desc && desc.local_video_src) {
                videoBtn.style.display = 'block';
                videoBtn.onclick = function() {
                    window.open(desc.local_video_src, '_blank');
                };
                // Hide YouTube button if local video exists
                if (youtubeBtn) {
                    youtubeBtn.style.display = 'none';
                }
            }
            
            if (instructions) {
                instructions.style.display = 'none';
            }
        }
        
        // Handle marker lost event
        function onMarkerLost(modelName) {
            console.log('‚ùå Marker lost:', modelName, new Date().toLocaleTimeString());
            
            // Only hide if this was the current model
            if (currentModel === modelName) {
                currentModel = null;
                
                // Stop any ongoing speech
                if (speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                }
                
                // Hide overlay, speak button, video buttons and show instructions
                var hoverMsg = document.getElementById('ar-hover-message');
                var speakBtn = document.getElementById('speak-button');
                var youtubeBtn = document.getElementById('youtube-button');
                var videoBtn = document.getElementById('video-button');
                var instructions = document.getElementById('instructions');
                
                if (hoverMsg) {
                    hoverMsg.style.display = 'none';
                }
                if (speakBtn) {
                    speakBtn.style.display = 'none';
                    speakBtn.classList.remove('speaking');
                    speakBtn.textContent = 'üîä Èü≥È†ªËß£Ë™™';
                }
                if (youtubeBtn) {
                    youtubeBtn.style.display = 'none';
                    youtubeBtn.onclick = null;
                }
                if (videoBtn) {
                    videoBtn.style.display = 'none';
                    videoBtn.onclick = null;
                }
                if (instructions) {
                    instructions.style.display = 'block';
                }
            }
        }
        
        // Initialize fallback mode for single model
        function initializeFallbackMode() {
            console.log('Initializing fallback single-model mode');
            // Fallback to original single model behavior
            var modelName = 'sputnik1';
            availableModels = [modelName];
            
            // Set default configs
            modelConfigs[modelName] = {
                size: 0.3, posX: 0, posY: 0, posZ: 0, rotX: 0, rotY: 0, rotZ: 0
            };
            modelDescriptions[modelName] = {
                title: 'AR Model',
                hk_narrative: 'Point camera at marker'
            };
            
            initializeARScene();
        }
        
        document.addEventListener('DOMContentLoaded', function () {
            // Scene initialization is now handled by the model loading process
            console.log('DOM loaded - waiting for model configurations...');
        });
        
        // Function to update AR message content
        function updateARMessage(modelName) {
            var desc = modelDescriptions[modelName];
            
            var titleEl = document.getElementById('model-title');
            
            if (titleEl && desc && desc.title) {
                titleEl.textContent = desc.title;
            }
        }
        
        // Speak the narrative using Web Speech API
        function speakNarrative(modelName) {
            var desc = modelDescriptions[modelName];
            
            if (!desc || !desc.hk_narrative) {
                console.warn('No narrative found for:', modelName);
                return;
            }
            
            // Stop any ongoing speech
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            
            // Create utterance
            currentUtterance = new SpeechSynthesisUtterance(desc.hk_narrative);
            
            // Set language to Cantonese (Hong Kong)
            currentUtterance.lang = 'zh-HK';
            
            // Try to find a Cantonese voice
            var voices = speechSynthesis.getVoices();
            var cantoneseVoice = voices.find(function(voice) {
                return voice.lang === 'zh-HK' || voice.lang.startsWith('zh-HK');
            });
            
            if (cantoneseVoice) {
                currentUtterance.voice = cantoneseVoice;
            }
            
            // Set speech parameters
            currentUtterance.rate = 0.9;
            currentUtterance.pitch = 1;
            currentUtterance.volume = 1;
            
            // Update button state
            var speakBtn = document.getElementById('speak-button');
            if (speakBtn) {
                speakBtn.classList.add('speaking');
                speakBtn.textContent = '‚èπ ÂÅúÊ≠¢';
            }
            
            // Handle speech end
            currentUtterance.onend = function() {
                if (speakBtn) {
                    speakBtn.classList.remove('speaking');
                    speakBtn.textContent = 'üîä Èü≥È†ªËß£Ë™™';
                }
            };
            
            // Handle speech error
            currentUtterance.onerror = function(event) {
                console.error('Speech error:', event);
                if (speakBtn) {
                    speakBtn.classList.remove('speaking');
                    speakBtn.textContent = 'üîä Èü≥È†ªËß£Ë™™';
                }
            };
            
            // Speak
            speechSynthesis.speak(currentUtterance);
            console.log('üîä Speaking:', desc.title);
        }
        
        // Toggle speech (play/stop)
        function toggleSpeech() {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
                var speakBtn = document.getElementById('speak-button');
                if (speakBtn) {
                    speakBtn.classList.remove('speaking');
                    speakBtn.textContent = 'üîä Èü≥È†ªËß£Ë™™';
                }
            } else if (currentModel) {
                speakNarrative(currentModel);
            }
        }
        
        // Initialize on page load
        window.addEventListener('load', function() {
            console.log('=== AR Viewer with Multi-Marker Support and Speech ===');
            
            // Set up speak button
            var speakBtn = document.getElementById('speak-button');
            if (speakBtn) {
                speakBtn.addEventListener('click', toggleSpeech);
            }
            
            // Load voices (needed for some browsers)
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = function() {
                    speechSynthesis.getVoices();
                };
            }
        });
    </script>
</body>
</html>
